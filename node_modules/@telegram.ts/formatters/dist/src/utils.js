"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.markdownV2Patterns = exports.markdownPatterns = exports.htmlEntityPatterns = void 0;
exports.parseEntities = parseEntities;
exports.escapeHTML = escapeHTML;
exports.escapeMarkdown = escapeMarkdown;
/**
 * Patterns used to match HTML entities in the text.
 */
const htmlEntityPatterns = {
    bold: /<b>(.*?)<\/b>|<strong>(.*?)<\/strong>/g,
    italic: /<i>(.*?)<\/i>|<em>(.*?)<\/em>/g,
    underline: /<u>(.*?)<\/u>|<ins>(.*?)<\/ins>/g,
    strikethrough: /<s>(.*?)<\/s>|<strike>(.*?)<\/strike>|<del>(.*?)<\/del>/g,
    spoiler: /<span class="tg-spoiler">(.*?)<\/span>/g,
    text_link: /<a href="([^"]+)">(.*?)<\/a>/g,
    text_mention: /<a href="tg:\/\/user\?id=(\d+)">(.*?)<\/a>/g,
    custom_emoji: /<tg-emoji emoji-id="([^"]+)">(.*?)<\/tg-emoji>/g,
    code: /<code>(.*?)<\/code>/g,
    pre: /<pre>(.*?)<\/pre>/g,
    blockquote: /<blockquote>(.*?)<\/blockquote>/g,
};
exports.htmlEntityPatterns = htmlEntityPatterns;
/**
 * Patterns used to match Markdown entities in the text.
 */
const markdownPatterns = {
    bold: /\*([^\*]+)\*/g,
    italic: /_([^_]+)_/g,
    text_link: /\[([^\]]+)\]\((http[^\)]+)\)/g,
    text_mention: /\[([^\]]+)\]\((tg:\/\/user\?id=\d+)\)/g,
    code: /`([^`]+)`/g,
    pre: /```([a-zA-Z]*)\n([\s\S]*?)```/g,
};
exports.markdownPatterns = markdownPatterns;
/**
 * Patterns used to match MarkdownV2 entities in the text.
 */
const markdownV2Patterns = {
    ...markdownPatterns,
    underline: /__([^_]+)__/g,
    strikethrough: /~([^~]+)~/g,
    spoiler: /\|\|([^|]+)\|\|/g,
};
exports.markdownV2Patterns = markdownV2Patterns;
/**
 * Parses text to extract entities based on the specified format.
 * @param text - The text to parse for entities.
 * @param format - The format of the text, either "HTML", "Markdown", or "MarkdownV2".
 * @returns An array of MessageEntity objects representing the parsed entities.
 */
function parseEntities(text, format) {
    var _a, _b, _c;
    const entities = [];
    /**
     * Adds an entity to the list of parsed entities.
     * @param type - The type of the entity.
     * @param offset - The offset of the entity in the text.
     * @param length - The length of the entity in the text.
     * @param extra - Additional properties specific to the entity type.
     */
    function addEntity(type, offset, length, extra = {}) {
        const entity = { type, offset, length, ...extra };
        entities.push(entity);
    }
    const entityPatterns = format === "HTML"
        ? htmlEntityPatterns
        : format === "MarkdownV2"
            ? markdownV2Patterns
            : markdownPatterns;
    for (const [type, regex] of Object.entries(entityPatterns)) {
        let match;
        while ((match = regex.exec(text)) !== null) {
            const [fullMatch, ...groups] = match;
            const offset = match.index;
            const length = fullMatch.length;
            if (type === "text_link") {
                const url = format === "HTML" ? groups[0] : groups[1];
                addEntity("text_link", offset, length, { url: url !== null && url !== void 0 ? url : "" });
            }
            else if (type === "text_mention") {
                addEntity("text_mention", offset, length, {
                    user: { id: (_a = groups[0]) !== null && _a !== void 0 ? _a : "0" },
                });
            }
            else if (type === "custom_emoji") {
                const customEmojiId = (_b = groups[0]) !== null && _b !== void 0 ? _b : "";
                addEntity("custom_emoji", offset, length, {
                    customEmojiId: customEmojiId,
                });
            }
            else if (type === "pre" && format === "MarkdownV2") {
                const language = (_c = groups[0]) !== null && _c !== void 0 ? _c : "";
                addEntity("pre", offset, length, { language });
            }
            else {
                addEntity(type, offset, length);
            }
        }
    }
    return entities.sort((a, b) => a.offset - b.offset);
}
/**
 * Escapes HTML special characters in a string.
 * @param content - The content to escape.
 * @returns The escaped string.
 */
function escapeHTML(content) {
    const escapables = {
        "<": "&lt;",
        ">": "&gt;",
        "&": "&amp;",
    };
    return content.replace(/[<>&]/g, (char) => { var _a; return (_a = escapables[char]) !== null && _a !== void 0 ? _a : char; });
}
/**
 * Escapes Markdown special characters in a string.
 * @param content - The content to escape.
 * @returns The escaped string.
 */
function escapeMarkdown(content) {
    const escapables = {
        _: "\\_",
        "*": "\\*",
        "[": "\\[",
        "]": "\\]",
        "(": "\\(",
        ")": "\\)",
        "~": "\\~",
        "`": "\\`",
        ">": "\\>",
        "#": "\\#",
        "+": "\\+",
        "-": "\\-",
        "=": "\\=",
        "|": "\\|",
        "{": "\\{",
        "}": "\\}",
        ".": "\\.",
        "!": "\\!",
    };
    return content.replace(/[_*\[\]()~`>#\+\-=|{}.!]/g, (char) => { var _a; return (_a = escapables[char]) !== null && _a !== void 0 ? _a : char; });
}
//# sourceMappingURL=utils.js.map