"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserManager = void 0;
const BaseManager_1 = require("./BaseManager");
const User_1 = require("../structures/misc/User");
const ChatFullInfo_1 = require("../structures/chat/ChatFullInfo");
const Message_1 = require("../structures/message/Message");
const ChatMember_1 = require("../structures/chat/ChatMember");
const TelegramError_1 = require("../errors/TelegramError");
const ErrorCodes_1 = require("../errors/ErrorCodes");
class UserManager extends BaseManager_1.BaseManager {
    constructor(client, iterable, options = {}) {
        super(client, User_1.User, iterable, options);
    }
    resolve(user) {
        if (user instanceof ChatMember_1.ChatMember && user.user) {
            return user.user;
        }
        if (user instanceof Message_1.Message && user.author) {
            return user.author;
        }
        return super.resolve(user);
    }
    resolveId(user) {
        if (user instanceof ChatMember_1.ChatMember && user.id) {
            return user.id;
        }
        if (user instanceof Message_1.Message && user.author) {
            return user.author.id;
        }
        return super.resolveId(user);
    }
    async fetch(user, { cache = true, force = false, fullInfo } = {}) {
        const id = this.resolveId(user);
        if (!force) {
            const existing = this.cache.get(String(id));
            if (existing)
                return existing;
        }
        const data = await this.client.rest.request("getChat", {
            chat_id: id,
        });
        if ((data === null || data === void 0 ? void 0 : data.type) !== "private") {
            throw new TelegramError_1.TelegramError(ErrorCodes_1.ErrorCodes.InvalidUserId);
        }
        if (fullInfo) {
            this._add(data, cache);
            return new ChatFullInfo_1.ChatFullInfo(this.client, data);
        }
        return this._add(data, cache);
    }
}
exports.UserManager = UserManager;
