"use strict";
var _MessageEntities_entities;
const tslib_1 = require("tslib");
const { Base } = require("../Base");
const { User } = require("../misc/User");
class MessageEntities extends Base {
    constructor(client, searchText, entities) {
        super(client);
        _MessageEntities_entities.set(this, void 0);
        this.searchText = searchText;
        tslib_1.__classPrivateFieldSet(this, _MessageEntities_entities, entities, "f");
    }
    get mention() {
        return this.searchEntity("mention");
    }
    get hashtag() {
        return this.searchEntity("hashtag");
    }
    get cashtag() {
        return this.searchEntity("cashtag");
    }
    get botCommand() {
        return this.searchEntity("bot_command");
    }
    get url() {
        return this.searchEntity("url");
    }
    get email() {
        return this.searchEntity("email");
    }
    get phoneNumber() {
        return this.searchEntity("phone_number");
    }
    get bold() {
        return this.searchEntity("bold");
    }
    get italic() {
        return this.searchEntity("italic");
    }
    get underline() {
        return this.searchEntity("underline");
    }
    get strikethrough() {
        return this.searchEntity("strikethrough");
    }
    get spoiler() {
        return this.searchEntity("spoiler");
    }
    get blockquote() {
        return this.searchEntity("blockquote");
    }
    get code() {
        return this.searchEntity("code");
    }
    get pre() {
        return this.searchEntity("pre");
    }
    get textLink() {
        return this.searchEntity("text_link").filter((entity) => "url" in entity);
    }
    get textMention() {
        return this.searchEntity("text_mention").filter((entity) => "user" in entity);
    }
    get customEmoji() {
        return this.searchEntity("custom_emoji").filter((entity) => "customEmojiId" in entity);
    }
    searchEntity(searchType) {
        const entities = [];
        tslib_1.__classPrivateFieldGet(this, _MessageEntities_entities, "f").forEach((entity, index) => {
            const { offset, length, type } = entity;
            if (type === searchType) {
                entities.push({
                    index,
                    offset,
                    length,
                    ...("language" in entity && { language: entity.language }),
                    ...("url" in entity && { url: entity.url }),
                    ...("user" in entity && { user: new User(this.client, entity.user) }),
                    ...("custom_emoji_id" in entity && {
                        customEmojiId: entity.custom_emoji_id,
                    }),
                    search: this.searchText.substring(offset, offset + length),
                });
            }
        });
        return entities;
    }
    *[(_MessageEntities_entities = new WeakMap(), Symbol.iterator)]() {
        const entityTypes = [
            "mention",
            "hashtag",
            "cashtag",
            "botCommand",
            "url",
            "email",
            "phoneNumber",
            "bold",
            "italic",
            "underline",
            "strikethrough",
            "spoiler",
            "blockquote",
            "code",
            "pre",
            "textLink",
            "textMention",
            "customEmoji",
        ];
        const sortedEntities = [];
        for (const type of entityTypes) {
            if (this[type] && Array.isArray(this[type])) {
                const results = this[type].map((entity) => ({
                    ...entity,
                    type,
                }));
                sortedEntities.push(...results);
            }
        }
        sortedEntities.sort((a, b) => a.index - b.index);
        for (const entity of sortedEntities) {
            yield entity;
        }
    }
}
module.exports = { MessageEntities };
