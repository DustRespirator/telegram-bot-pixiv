"use strict";
const { Base } = require("../Base");
const { UsersShared } = require("../misc/UsersShared");
const { ChatShared } = require("../misc/ChatShared");
const { ChatMember } = require("../chat/ChatMember");
const { Story } = require("../story/Story");
const { VideoChatParticipantsInvited, } = require("../chat/VideoChatParticipantsInvited");
const { Game } = require("../game/Game");
const { Animation } = require("../media/Animation");
const { Audio } = require("../media/Audio");
const { Contact } = require("../media/Contact");
const { Dice } = require("../media/Dice");
const { Document } = require("../media/Document");
const { Photo } = require("../media/Photo");
const { Poll } = require("../media/Poll");
const { Sticker } = require("../media/Sticker");
const { Video } = require("../media/Video");
const { VideoNote } = require("../media/VideoNote");
const { Voice } = require("../media/Voice");
const { PaidMediaInfo } = require("../media/paid/PaidMediaInfo");
const { SuccessfulPayment } = require("../invoice/SuccessfulPayment");
const { Location } = require("../misc/Location");
const { Venue } = require("../misc/Venue");
const { LinkPreviewOptions } = require("../misc/LinkPreviewOptions");
const { RefundedPayment } = require("../invoice/RefundedPayment");
const { MessageOrigin } = require("../message/MessageOrigin");
const { MessageEntities } = require("../message/MessageEntities");
const { ExternalReplyInfo } = require("../misc/ExternalReplyInfo");
const { ChatBackground } = require("../chat/ChatBackground");
const { Giveaway } = require("../giveaway/Giveaway");
const { GiveawayWinners } = require("../giveaway/GiveawayWinners");
const { GiveawayCompleted } = require("../giveaway/GiveawayCompleted");
const { VideoChatScheduled } = require("../chat/VideoChatScheduled");
const { Forum } = require("../forum/Forum");
const { ForumTopic } = require("../forum/ForumTopic");
const { TextQuote } = require("../misc/TextQuote");
const { PassportData } = require("../passport/PassportData");
const { MessageCollector } = require("../../util/collector/MessageCollector");
const { ReactionCollector } = require("../../util/collector/ReactionCollector");
const { InlineKeyboardCollector, } = require("../../util/collector/InlineKeyboardCollector");
const { CollectorEvents, ReactionCollectorEvents, } = require("../../util/Constants");
const { ReactionType } = require("../misc/ReactionType");
const { GiftInfo } = require("../gift/GiftInfo");
const { UniqueGiftInfo } = require("../gift/UniqueGiftInfo");
const { TelegramError } = require("../../errors/TelegramError");
const { ErrorCodes } = require("../../errors/ErrorCodes");
const { Collection } = require("@telegram.ts/collection");
class Message extends Base {
    constructor(client, data) {
        super(client);
        this.id = String(data.message_id);
        this._patch(data);
        this.createdUnixTime = data.date;
        if ("edit_date" in data) {
            this.editedUnixTime = data.edit_date;
        }
    }
    _patch(data) {
        var _a, _b;
        if ("message_thread_id" in data) {
            this.threadId = String(data.message_thread_id);
        }
        if ("from" in data) {
            this.author = this.client.users._add(data.from);
        }
        if ("is_topic_message" in data) {
            if ("chat" in this && this.chat && "threadId" in this && this.threadId) {
                this.forum = new Forum(this.client, this.threadId, this.chat.id);
            }
            this.inTopic = data.is_topic_message;
        }
        if ("chat" in data) {
            this.chat = this.client.chats._add({
                ...data.chat,
                ...(data.chat.type !== "private" && {
                    threadId: this.threadId,
                    inTopic: this.inTopic,
                }),
            });
            if (!this.chat.isPrivate() && data.from) {
                this.member = new ChatMember(this.client, this.chat.id, {
                    user: data.from,
                    status: "member",
                });
            }
        }
        if ("text" in data) {
            this.content = data.text;
        }
        if ("caption" in data) {
            this.caption = data.caption;
        }
        if ("caption_entities" in data && "caption" in data) {
            this.captionEntities = new MessageEntities(this.client, data.caption, data.caption_entities);
        }
        if ("entities" in data && "text" in data) {
            this.entities = new MessageEntities(this.client, data.text, data.entities);
        }
        if ("sender_boost_count" in data) {
            this.senderBoostCount = data.sender_boost_count;
        }
        if ("sender_business_bot" in data) {
            this.senderBusinessBot = this.client.users._add(data.sender_business_bot);
        }
        if ("forward_origin" in data) {
            this.forwardOrigin = new MessageOrigin(this.client, data.forward_origin);
        }
        if ("is_automatic_forward" in data) {
            this.automaticForward = data.is_automatic_forward;
        }
        if ("reply_to_message" in data) {
            this.originalMessage = new Message(this.client, data.reply_to_message);
        }
        if ("external_reply" in data) {
            this.externalReply = new ExternalReplyInfo(this.client, data.external_reply);
        }
        if ("quote" in data) {
            this.quote = new TextQuote(this.client, data.quote);
        }
        if ("story" in data) {
            this.story = new Story(this.client, data.story);
        }
        if ("via_bot" in data) {
            this.viaBot = this.client.users._add(data.via_bot);
        }
        if ("has_protected_content" in data) {
            this.protectedContent = data.has_protected_content;
        }
        if ("show_caption_above_media" in data) {
            this.showAboveMedia = data.show_caption_above_media;
        }
        if ("is_from_offline" in data) {
            this.authorOffline = data.is_from_offline;
        }
        if ("author_signature" in data) {
            this.authorSignature = data.author_signature;
        }
        if ("link_preview_options" in data) {
            this.linkPreviewOpts = new LinkPreviewOptions(data.link_preview_options);
        }
        if ("effect_id" in data) {
            this.effectId = data.effect_id;
        }
        if ("paid_star_count" in data) {
            this.paidStarCount = data.paid_star_count;
        }
        if ("sender_chat" in data) {
            this.senderChat = this.client.chats._add({
                ...data.sender_chat,
                ...(data.sender_chat.type !== "private" && {
                    threadId: this.threadId,
                    inTopic: this.inTopic,
                }),
            });
        }
        if ("business_connection_id" in data) {
            this.businessId = data.business_connection_id;
        }
        if ("new_chat_members" in data) {
            this.newChatMembers = new Collection(data.new_chat_members.map((user) => [
                String(user.id),
                this.client.users._add(user),
            ]));
        }
        if ("left_chat_member" in data) {
            this.leftChatMember = this.client.users._add(data.left_chat_member);
        }
        if ("new_chat_title" in data) {
            this.newChatTitle = data.new_chat_title;
        }
        if ("new_chat_photo" in data) {
            this.newChatPhoto = data.new_chat_photo.map((photo) => new Photo(this.client, photo));
        }
        if ("delete_chat_photo" in data) {
            this.deleteChatPhoto = data.delete_chat_photo;
        }
        if ("group_chat_created" in data) {
            this.groupChatCreated = data.group_chat_created;
        }
        if ("supergroup_chat_created" in data) {
            this.supergroupChatCreated = data.supergroup_chat_created;
        }
        if ("channel_chat_created" in data) {
            this.channelChatCreated = data.channel_chat_created;
        }
        if ("message_auto_delete_timer_changed" in data) {
            const messageAutoDeleteTimerChanged = {
                autoDelTime: data.message_auto_delete_timer_changed.message_auto_delete_time,
            };
            this.autoDelTimerChanged = messageAutoDeleteTimerChanged;
        }
        if ("migrate_to_chat_id" in data) {
            this.migrateFromChatId = String(data.migrate_to_chat_id);
        }
        if ("successful_payment" in data) {
            this.successfulPayment = new SuccessfulPayment(this.client, data.successful_payment);
        }
        if ("refunded_payment" in data) {
            this.refundedPayment = new RefundedPayment(this.client, data.refunded_payment);
        }
        if ("users_shared" in data) {
            this.usersShared = new UsersShared(this.client, data.users_shared);
        }
        if ("chat_shared" in data) {
            this.chatShared = new ChatShared(this.client, data.chat_shared);
        }
        if ("connected_website" in data) {
            this.connectedWebsite = data.connected_website;
        }
        if ("write_access_allowed" in data) {
            const writeAccessAllowed = {};
            if ("from_request" in data.write_access_allowed) {
                writeAccessAllowed.authorRequest =
                    data.write_access_allowed.from_request;
            }
            if ("web_app_name" in data.write_access_allowed) {
                writeAccessAllowed.appName = data.write_access_allowed.web_app_name;
            }
            if ("from_attachment_menu" in data.write_access_allowed) {
                writeAccessAllowed.authorAttachmentMenu =
                    data.write_access_allowed.from_attachment_menu;
            }
            this.writeAccessAllowed = writeAccessAllowed;
        }
        if ("passport_data" in data) {
            this.passport = new PassportData(this.client, data.passport_data);
        }
        if ("proximity_alert_triggered" in data) {
            const proximityAlertTriggered = {
                traveler: this.client.users._add(data.proximity_alert_triggered.traveler),
                watcher: this.client.users._add(data.proximity_alert_triggered.watcher),
                distance: data.proximity_alert_triggered.distance,
            };
            this.proximityAlertTriggered = proximityAlertTriggered;
        }
        if ("boost_added" in data) {
            const boostAdded = {
                count: data.boost_added.boost_count,
            };
            this.boostAdded = boostAdded;
        }
        if ("chat_background_set" in data) {
            this.chatBackgroundSet = new ChatBackground(this.client, data.chat_background_set);
        }
        if ("forum_topic_created" in data && this.threadId && this.chat) {
            this.forumCreated = new ForumTopic(this.client, this.threadId, (_a = this.chat) === null || _a === void 0 ? void 0 : _a.id, data.forum_topic_created);
        }
        if ("forum_topic_edited" in data && this.threadId && this.chat) {
            this.forumEdited = new ForumTopic(this.client, this.threadId, (_b = this.chat) === null || _b === void 0 ? void 0 : _b.id, data.forum_topic_edited);
        }
        if ("forum_topic_closed" in data) {
            this.forumClosed = true;
        }
        if ("forum_topic_reopened" in data) {
            this.forumTopicReopened = true;
        }
        if ("general_forum_topic_hidden" in data) {
            this.generalForumHidden = true;
        }
        if ("general_forum_topic_unhidden" in data) {
            this.generalForumUnhidden = true;
        }
        if ("giveaway_created" in data) {
            this.giveawayCreated = {
                ...("prize_star_count" in data.giveaway_created && {
                    starCount: data.giveaway_created.prize_star_count,
                }),
            };
        }
        if ("giveaway" in data) {
            this.giveaway = new Giveaway(this.client, data.giveaway);
        }
        if ("giveaway_winners" in data) {
            this.giveawayWinners = new GiveawayWinners(this.client, data.giveaway_winners);
        }
        if ("giveaway_completed" in data) {
            this.giveawayCompleted = new GiveawayCompleted(this.client, data.giveaway_completed);
        }
        if ("gift" in data) {
            this.gift = new GiftInfo(this.client, data.gift);
        }
        if ("unique_gift" in data) {
            this.uniqueGift = new UniqueGiftInfo(this.client, data.unique_gift);
        }
        if ("paid_message_price_changed" in data) {
            this.paidPriceStartCount =
                data.paid_message_price_changed.paid_message_star_count;
        }
        if ("video_chat_scheduled" in data) {
            this.videoChatScheduled = new VideoChatScheduled(data.video_chat_scheduled);
        }
        if ("video_chat_started" in data) {
            this.videoChatStarted = true;
        }
        if ("video_chat_ended" in data) {
            this.videoChatEnded = data.video_chat_ended;
        }
        if ("video_chat_participants_invited" in data) {
            this.videoChatParticiInvited = new VideoChatParticipantsInvited(this.client, data.video_chat_participants_invited);
        }
        if ("web_app_data" in data) {
            const webAppData = {
                data: data.web_app_data.data,
                text: data.web_app_data.button_text,
            };
            this.webApp = webAppData;
        }
        if ("location" in data) {
            this.location = new Location(this.client, data.location);
        }
        if ("paid_media" in data) {
            this.paidMedia = new PaidMediaInfo(this.client, data.paid_media);
        }
        if ("animation" in data) {
            this.animation = new Animation(this.client, data.animation);
        }
        if ("audio" in data) {
            this.audio = new Audio(this.client, data.audio);
        }
        if ("document" in data) {
            this.document = new Document(this.client, data.document);
        }
        if ("photo" in data) {
            this.photo = data.photo.map((photo) => new Photo(this.client, photo));
        }
        if ("video" in data) {
            this.video = new Video(this.client, data.video);
        }
        if ("video_note" in data) {
            this.videoNote = new VideoNote(this.client, data.video_note);
        }
        if ("voice" in data) {
            this.voice = new Voice(this.client, data.voice);
        }
        if ("sticker" in data) {
            this.sticker = new Sticker(this.client, data.sticker);
        }
        if ("contact" in data) {
            this.contact = new Contact(data.contact);
        }
        if ("poll" in data) {
            this.poll = new Poll(this.client, data.poll);
        }
        if ("venue" in data) {
            this.venue = new Venue(this.client, data.venue);
        }
        if ("game" in data) {
            this.game = new Game(this.client, data.game);
        }
        if ("dice" in data) {
            this.dice = new Dice(data.dice);
        }
        return data;
    }
    isEdited() {
        return Boolean(this.editedUnixTime && this.editedTimestamp && this.editedAt);
    }
    isPendingVideoMessage() {
        return this.id === "0";
    }
    get createdTimestamp() {
        return this.createdUnixTime * 1000;
    }
    get createdAt() {
        return new Date(this.createdTimestamp);
    }
    get editedTimestamp() {
        return this.editedUnixTime ? this.editedUnixTime * 1000 : null;
    }
    get editedAt() {
        return this.editedTimestamp ? new Date(this.editedTimestamp) : null;
    }
    createMessageCollector(options = {}) {
        if (!this.chat) {
            throw new TelegramError(ErrorCodes.ChatIdNotAvailable);
        }
        return new MessageCollector(this.client, this.chat, options);
    }
    awaitMessage(options = {}) {
        const _options = { ...options, max: 1 };
        return new Promise((resolve) => {
            const collect = this.createMessageCollector(_options);
            collect.on(CollectorEvents.End, (collections, reason) => {
                resolve([collections, reason]);
            });
        });
    }
    awaitMessages(options = {}) {
        return new Promise((resolve, reject) => {
            const collect = this.createMessageCollector(options);
            collect.on(CollectorEvents.End, (collections, reason) => {
                var _a;
                if ((_a = options.errors) === null || _a === void 0 ? void 0 : _a.includes(reason)) {
                    reject(collections);
                }
                else {
                    resolve(collections);
                }
            });
        });
    }
    createReactionCollector(options = {}) {
        if (!this.chat) {
            throw new TelegramError(ErrorCodes.ChatIdNotAvailable);
        }
        return new ReactionCollector(this.client, this.chat, options);
    }
    awaitReaction(options = {}) {
        const _options = { ...options, max: 1 };
        return new Promise((resolve) => {
            const collect = this.createReactionCollector(_options);
            collect.on(ReactionCollectorEvents.End, (collections, reason) => {
                resolve([collections, reason]);
            });
        });
    }
    awaitReactions(options = {}) {
        return new Promise((resolve, reject) => {
            const collect = this.createReactionCollector(options);
            collect.on(ReactionCollectorEvents.End, (collections, reason) => {
                var _a;
                if ((_a = options.errors) === null || _a === void 0 ? void 0 : _a.includes(reason)) {
                    reject(collections);
                }
                else {
                    resolve(collections);
                }
            });
        });
    }
    createMessageComponentCollector(options = {}) {
        return new InlineKeyboardCollector(this.client, options);
    }
    reply(text, options = {}) {
        if (!this.chat) {
            throw new TelegramError(ErrorCodes.ChatIdNotAvailable);
        }
        return this.client.sendMessage({
            text,
            chatId: this.chat.id,
            ...(this.threadId && this.inTopic && { messageThreadId: this.threadId }),
            replyParameters: {
                message_id: this.id,
            },
            ...options,
        });
    }
    react(reaction, isBig) {
        if (!this.chat) {
            throw new TelegramError(ErrorCodes.ChatIdNotAvailable);
        }
        let react = [];
        if (typeof reaction === "string") {
            react.push({ type: "emoji", emoji: reaction });
        }
        else if (reaction instanceof ReactionType) {
            const reactionData = reaction.isEmoji()
                ? { type: "emoji", emoji: reaction.emoji }
                : { type: "custom_emoji", customEmojiId: reaction.customEmojiId };
            react.push(reactionData);
        }
        else if (Array.isArray(reaction)) {
            reaction.forEach((rea) => {
                if (rea instanceof ReactionType) {
                    const reactionData = rea.isEmoji()
                        ? { type: "emoji", emoji: rea.emoji }
                        : { type: "custom_emoji", customEmojiId: rea.customEmojiId };
                    react.push(reactionData);
                }
                else {
                    react.push(rea);
                }
            });
        }
        else if (typeof reaction === "object") {
            react.push(reaction);
        }
        else {
            react = reaction;
        }
        return this.client.setMessageReaction({
            reaction: react,
            chatId: this.chat.id,
            messageId: this.id,
            ...(isBig && { isBig }),
        });
    }
    edit(text, options = {}) {
        if (!this.chat) {
            throw new TelegramError(ErrorCodes.ChatIdNotAvailable);
        }
        return this.client.editMessageText({
            text,
            chatId: this.chat.id,
            messageId: this.id,
            ...options,
        });
    }
    editCaption(caption, options = {}) {
        if (!this.chat) {
            throw new TelegramError(ErrorCodes.ChatIdNotAvailable);
        }
        return this.client.editMessageCaption({
            ...(caption && { caption }),
            chatId: this.chat.id,
            messageId: this.id,
            ...options,
        });
    }
    editMedia(media, options = {}) {
        if (!this.chat) {
            throw new TelegramError(ErrorCodes.ChatIdNotAvailable);
        }
        return this.client.editMessageMedia({
            media,
            chatId: this.chat.id,
            messageId: this.id,
            ...options,
        });
    }
    editReplyMarkup(replyMarkup, options = {}) {
        if (!this.chat) {
            throw new TelegramError(ErrorCodes.ChatIdNotAvailable);
        }
        return this.client.editMessageReplyMarkup({
            replyMarkup,
            chatId: this.chat.id,
            messageId: this.id,
            ...options,
        });
    }
    forward(chatId, options = {}) {
        if (!this.chat) {
            throw new TelegramError(ErrorCodes.ChatIdNotAvailable);
        }
        return this.client.forwardMessage({
            chatId,
            ...(this.threadId && this.inTopic && { messageThreadId: this.threadId }),
            fromChatId: this.chat.id,
            messageId: this.id,
            ...options,
        });
    }
    copy(chatId, options = {}) {
        if (!this.chat) {
            throw new TelegramError(ErrorCodes.ChatIdNotAvailable);
        }
        return this.client.copyMessage({
            chatId: chatId,
            fromChatId: this.chat.id,
            messageId: this.id,
            ...options,
        });
    }
    pin({ notification = false, businessConnectionId } = {}) {
        if (!this.chat) {
            throw new TelegramError(ErrorCodes.ChatIdNotAvailable);
        }
        return this.client.pinChatMessage({
            chatId: this.chat.id,
            messageId: this.id,
            disableNotification: notification,
            ...(businessConnectionId && { businessConnectionId }),
        });
    }
    unpin(businessConnectionId) {
        if (!this.chat) {
            throw new TelegramError(ErrorCodes.ChatIdNotAvailable);
        }
        return this.client.unpinChatMessage({
            chatId: this.chat.id,
            messageId: this.id,
            ...(businessConnectionId && { businessConnectionId }),
        });
    }
    delete() {
        if (!this.chat) {
            throw new TelegramError(ErrorCodes.ChatIdNotAvailable);
        }
        return this.client.deleteMessage(this.chat.id, this.id);
    }
    editLiveLocation(latitude, longitude, options = {}) {
        if (!this.chat) {
            throw new TelegramError(ErrorCodes.ChatIdNotAvailable);
        }
        return this.client.editMessageLiveLocation({
            chatId: this.chat.id,
            messageId: this.id,
            latitude,
            longitude,
            ...options,
        });
    }
    stopLiveLocation(options = {}) {
        if (!this.chat) {
            throw new TelegramError(ErrorCodes.ChatIdNotAvailable);
        }
        return this.client.stopMessageLiveLocation({
            chatId: this.chat.id,
            messageId: this.id,
            ...options,
        });
    }
    toString() {
        var _a, _b;
        return (_b = (_a = this.content) !== null && _a !== void 0 ? _a : this.caption) !== null && _b !== void 0 ? _b : "";
    }
}
module.exports = { Message };
