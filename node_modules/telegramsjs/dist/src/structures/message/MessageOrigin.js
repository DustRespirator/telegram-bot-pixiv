"use strict";
const { Base } = require("../Base");
const { TelegramError } = require("../../errors/TelegramError");
const { ErrorCodes } = require("../../errors/ErrorCodes");
const { ReactionType } = require("../misc/ReactionType");
const { MessageCollector } = require("../../util/collector/MessageCollector");
const { ReactionCollector } = require("../../util/collector/ReactionCollector");
const { InlineKeyboardCollector, } = require("../../util/collector/InlineKeyboardCollector");
const { CollectorEvents, ReactionCollectorEvents, } = require("../../util/Constants");
class MessageOrigin extends Base {
    constructor(client, data) {
        super(client);
        this.createdUnixTime = data.date;
        this._patch(data);
    }
    _patch(data) {
        if ("message_id" in data) {
            this.id = String(data.message_id);
        }
        if ("sender_user" in data) {
            this.senderUser = this.client.users._add(data.sender_user);
        }
        if ("sender_user_name" in data) {
            this.username = data.sender_user_name;
        }
        if ("sender_chat" in data) {
            this.senderChat = this.client.chats._add(data.sender_chat);
        }
        if ("chat" in data) {
            this.chat = this.client.chats._add(data.chat);
        }
        if ("author_signature" in data) {
            this.authorSignature = data.author_signature;
        }
        return data;
    }
    isUser() {
        return Boolean("senderUser" in this && this.senderUser);
    }
    isHiddenUser() {
        return Boolean("username" in this && this.username);
    }
    isChat() {
        return Boolean("senderChat" in this && this.senderChat);
    }
    isChennel() {
        return Boolean("id" in this && this.id && "chat" in this && this.chat);
    }
    createMessageCollector(options = {}) {
        if (!this.chat) {
            throw new TelegramError(ErrorCodes.ChatIdNotAvailable);
        }
        return new MessageCollector(this.client, this.chat, options);
    }
    awaitMessage(options = {}) {
        const _options = { ...options, max: 1 };
        return new Promise((resolve) => {
            const collect = this.createMessageCollector(_options);
            collect.on(CollectorEvents.End, (collections, reason) => {
                resolve([collections, reason]);
            });
        });
    }
    awaitMessages(options = {}) {
        return new Promise((resolve, reject) => {
            const collect = this.createMessageCollector(options);
            collect.on(CollectorEvents.End, (collections, reason) => {
                var _a;
                if ((_a = options.errors) === null || _a === void 0 ? void 0 : _a.includes(reason)) {
                    reject(collections);
                }
                else {
                    resolve(collections);
                }
            });
        });
    }
    createReactionCollector(options = {}) {
        if (!this.chat) {
            throw new TelegramError(ErrorCodes.ChatIdNotAvailable);
        }
        return new ReactionCollector(this.client, this.chat, options);
    }
    awaitReaction(options = {}) {
        const _options = { ...options, max: 1 };
        return new Promise((resolve) => {
            const collect = this.createReactionCollector(_options);
            collect.on(ReactionCollectorEvents.End, (collections, reason) => {
                resolve([collections, reason]);
            });
        });
    }
    awaitReactions(options = {}) {
        return new Promise((resolve, reject) => {
            const collect = this.createReactionCollector(options);
            collect.on(ReactionCollectorEvents.End, (collections, reason) => {
                var _a;
                if ((_a = options.errors) === null || _a === void 0 ? void 0 : _a.includes(reason)) {
                    reject(collections);
                }
                else {
                    resolve(collections);
                }
            });
        });
    }
    createMessageComponentCollector(options = {}) {
        return new InlineKeyboardCollector(this.client, options);
    }
    reply(text, options = {}) {
        if (!this.id) {
            throw new TelegramError(ErrorCodes.MessageIdNotAvailable);
        }
        if (!this.chat) {
            throw new TelegramError(ErrorCodes.ChatIdNotAvailable);
        }
        return this.client.sendMessage({
            text,
            chatId: this.chat.id,
            replyParameters: {
                message_id: this.id,
            },
            ...options,
        });
    }
    react(reaction, isBig) {
        if (!this.id) {
            throw new TelegramError(ErrorCodes.MessageIdNotAvailable);
        }
        if (!this.chat) {
            throw new TelegramError(ErrorCodes.ChatIdNotAvailable);
        }
        let react = [];
        if (typeof reaction === "string") {
            react.push({ type: "emoji", emoji: reaction });
        }
        else if (reaction instanceof ReactionType) {
            const reactionData = reaction.isEmoji()
                ? { type: "emoji", emoji: reaction.emoji }
                : { type: "custom_emoji", customEmojiId: reaction.customEmojiId };
            react.push(reactionData);
        }
        else if (Array.isArray(reaction)) {
            reaction.forEach((rea) => {
                if (rea instanceof ReactionType) {
                    const reactionData = rea.isEmoji()
                        ? { type: "emoji", emoji: rea.emoji }
                        : { type: "custom_emoji", customEmojiId: rea.customEmojiId };
                    react.push(reactionData);
                }
                else {
                    react.push(rea);
                }
            });
        }
        else if (typeof reaction === "object") {
            react.push(reaction);
        }
        else {
            react = reaction;
        }
        return this.client.setMessageReaction({
            reaction: react,
            chatId: this.chat.id,
            messageId: this.id,
            ...(isBig && { isBig }),
        });
    }
    edit(text, options = {}) {
        if (!this.id) {
            throw new TelegramError(ErrorCodes.MessageIdNotAvailable);
        }
        if (!this.chat) {
            throw new TelegramError(ErrorCodes.ChatIdNotAvailable);
        }
        return this.client.editMessageText({
            text,
            chatId: this.chat.id,
            messageId: this.id,
            ...options,
        });
    }
    editCaption(caption, options = {}) {
        if (!this.id) {
            throw new TelegramError(ErrorCodes.MessageIdNotAvailable);
        }
        if (!this.chat) {
            throw new TelegramError(ErrorCodes.ChatIdNotAvailable);
        }
        return this.client.editMessageCaption({
            chatId: this.chat.id,
            messageId: this.id,
            ...(caption && { caption }),
            ...options,
        });
    }
    editMedia(media, options = {}) {
        if (!this.id) {
            throw new TelegramError(ErrorCodes.MessageIdNotAvailable);
        }
        if (!this.chat) {
            throw new TelegramError(ErrorCodes.ChatIdNotAvailable);
        }
        return this.client.editMessageMedia({
            media,
            chatId: this.chat.id,
            messageId: this.id,
            ...options,
        });
    }
    editReplyMarkup(replyMarkup, options = {}) {
        if (!this.id) {
            throw new TelegramError(ErrorCodes.MessageIdNotAvailable);
        }
        if (!this.chat) {
            throw new TelegramError(ErrorCodes.ChatIdNotAvailable);
        }
        return this.client.editMessageReplyMarkup({
            replyMarkup,
            chatId: this.chat.id,
            messageId: this.id,
            ...options,
        });
    }
    forward(chatId, options = {}) {
        if (!this.id) {
            throw new TelegramError(ErrorCodes.MessageIdNotAvailable);
        }
        if (!this.chat) {
            throw new TelegramError(ErrorCodes.ChatIdNotAvailable);
        }
        return this.client.forwardMessage({
            chatId: chatId,
            fromChatId: this.chat.id,
            messageId: this.id,
            ...options,
        });
    }
    copy(chatId, options = {}) {
        if (!this.id) {
            throw new TelegramError(ErrorCodes.MessageIdNotAvailable);
        }
        if (!this.chat) {
            throw new TelegramError(ErrorCodes.ChatIdNotAvailable);
        }
        return this.client.copyMessage({
            chatId: chatId,
            fromChatId: this.chat.id,
            messageId: this.id,
            ...options,
        });
    }
    pin({ notification = false, businessConnectionId } = {}) {
        if (!this.id) {
            throw new TelegramError(ErrorCodes.MessageIdNotAvailable);
        }
        if (!this.chat) {
            throw new TelegramError(ErrorCodes.ChatIdNotAvailable);
        }
        return this.client.pinChatMessage({
            chatId: this.chat.id,
            messageId: this.id,
            disableNotification: notification,
            ...(businessConnectionId && { businessConnectionId }),
        });
    }
    unpin(businessConnectionId) {
        if (!this.id) {
            throw new TelegramError(ErrorCodes.MessageIdNotAvailable);
        }
        if (!this.chat) {
            throw new TelegramError(ErrorCodes.ChatIdNotAvailable);
        }
        return this.client.unpinChatMessage({
            chatId: this.chat.id,
            messageId: this.id,
            ...(businessConnectionId && { businessConnectionId }),
        });
    }
    delete() {
        if (!this.id) {
            throw new TelegramError(ErrorCodes.MessageIdNotAvailable);
        }
        if (!this.chat) {
            throw new TelegramError(ErrorCodes.ChatIdNotAvailable);
        }
        return this.client.deleteMessage(this.chat.id, this.id);
    }
    editLiveLocation(latitude, longitude, options = {}) {
        if (!this.id) {
            throw new TelegramError(ErrorCodes.MessageIdNotAvailable);
        }
        if (!this.chat) {
            throw new TelegramError(ErrorCodes.ChatIdNotAvailable);
        }
        return this.client.editMessageLiveLocation({
            chatId: this.chat.id,
            messageId: this.id,
            latitude,
            longitude,
            ...options,
        });
    }
    stopLiveLocation(options = {}) {
        if (!this.id) {
            throw new TelegramError(ErrorCodes.MessageIdNotAvailable);
        }
        if (!this.chat) {
            throw new TelegramError(ErrorCodes.ChatIdNotAvailable);
        }
        return this.client.stopMessageLiveLocation({
            chatId: this.chat.id,
            messageId: this.id,
            ...options,
        });
    }
    get createdTimestamp() {
        return this.createdUnixTime * 1000;
    }
    get createdAt() {
        return new Date(this.createdTimestamp);
    }
}
module.exports = { MessageOrigin };
