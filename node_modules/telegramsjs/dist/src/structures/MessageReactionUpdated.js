"use strict";
const { Base } = require("./Base");
const { ReactionType } = require("./misc/ReactionType");
const { MessageCollector } = require("../util/collector/MessageCollector");
const { ReactionCollector } = require("../util/collector/ReactionCollector");
const { InlineKeyboardCollector, } = require("../util/collector/InlineKeyboardCollector");
const { CollectorEvents, ReactionCollectorEvents, } = require("../util/Constants");
class MessageReactionUpdated extends Base {
    constructor(client, data) {
        super(client);
        this.id = String(data.message_id);
        this.chat = this.client.chats._add(data.chat);
        if ("user" in data) {
            this.user = this.client.users._add(data.user);
        }
        if ("actor_chat" in data) {
            this.actorChat = this.client.chats._add(data.actor_chat);
        }
        this.createdUnixTime = data.date;
        const reactionData = reactions({
            added: data.new_reaction.map((reaction) => new ReactionType(reaction)),
            removed: data.old_reaction.map((reaction) => new ReactionType(reaction)),
        });
        if (reactionData.isEmoji()) {
            this.emojiSummary = reactionData.emoji;
        }
        if (reactionData.isCustomEmoji()) {
            this.customEmojiSummary = reactionData.customEmoji;
        }
        if (reactionData.isPaidEmoji()) {
            this.paidEmoji = reactionData.paid;
        }
    }
    get createdTimestamp() {
        return this.createdUnixTime * 1000;
    }
    get createdAt() {
        return new Date(this.createdTimestamp);
    }
    createMessageCollector(options = {}) {
        return new MessageCollector(this.client, this.chat, options);
    }
    awaitMessage(options = {}) {
        const _options = { ...options, max: 1 };
        return new Promise((resolve) => {
            const collect = this.createMessageCollector(_options);
            collect.on(CollectorEvents.End, (collections, reason) => {
                resolve([collections, reason]);
            });
        });
    }
    awaitMessages(options = {}) {
        return new Promise((resolve, reject) => {
            const collect = this.createMessageCollector(options);
            collect.on(CollectorEvents.End, (collections, reason) => {
                var _a;
                if ((_a = options.errors) === null || _a === void 0 ? void 0 : _a.includes(reason)) {
                    reject(collections);
                }
                else {
                    resolve(collections);
                }
            });
        });
    }
    createReactionCollector(options = {}) {
        return new ReactionCollector(this.client, this.chat, options);
    }
    awaitReaction(options = {}) {
        const _options = { ...options, max: 1 };
        return new Promise((resolve) => {
            const collect = this.createReactionCollector(_options);
            collect.on(ReactionCollectorEvents.End, (collections, reason) => {
                resolve([collections, reason]);
            });
        });
    }
    awaitReactions(options = {}) {
        return new Promise((resolve, reject) => {
            const collect = this.createReactionCollector(options);
            collect.on(ReactionCollectorEvents.End, (collections, reason) => {
                var _a;
                if ((_a = options.errors) === null || _a === void 0 ? void 0 : _a.includes(reason)) {
                    reject(collections);
                }
                else {
                    resolve(collections);
                }
            });
        });
    }
    createMessageComponentCollector(options = {}) {
        return new InlineKeyboardCollector(this.client, options);
    }
    reply(text, options = {}) {
        return this.client.sendMessage({
            text,
            chatId: this.chat.id,
            replyParameters: {
                message_id: this.id,
            },
            ...options,
        });
    }
    react(reaction, isBig) {
        let react = [];
        if (typeof reaction === "string") {
            react.push({ type: "emoji", emoji: reaction });
        }
        else if (reaction instanceof ReactionType) {
            const reactionData = reaction.isEmoji()
                ? { type: "emoji", emoji: reaction.emoji }
                : { type: "custom_emoji", customEmojiId: reaction.customEmojiId };
            react.push(reactionData);
        }
        else if (Array.isArray(reaction)) {
            reaction.forEach((rea) => {
                if (rea instanceof ReactionType) {
                    const reactionData = rea.isEmoji()
                        ? { type: "emoji", emoji: rea.emoji }
                        : { type: "custom_emoji", customEmojiId: rea.customEmojiId };
                    react.push(reactionData);
                }
                else {
                    react.push(rea);
                }
            });
        }
        else if (typeof reaction === "object") {
            react.push(reaction);
        }
        else {
            react = reaction;
        }
        return this.client.setMessageReaction({
            reaction: react,
            chatId: this.chat.id,
            messageId: this.id,
            ...(isBig && { isBig }),
        });
    }
    edit(text, options = {}) {
        return this.client.editMessageText({
            text,
            chatId: this.chat.id,
            messageId: this.id,
            ...options,
        });
    }
    editCaption(caption, options = {}) {
        return this.client.editMessageCaption({
            ...(caption && { caption }),
            chatId: this.chat.id,
            messageId: this.id,
            ...options,
        });
    }
    editMedia(media, options = {}) {
        return this.client.editMessageMedia({
            media,
            chatId: this.chat.id,
            messageId: this.id,
            ...options,
        });
    }
    editReplyMarkup(replyMarkup, options = {}) {
        return this.client.editMessageReplyMarkup({
            replyMarkup,
            chatId: this.chat.id,
            messageId: this.id,
            ...options,
        });
    }
    forward(chatId, options = {}) {
        return this.client.forwardMessage({
            chatId: chatId,
            fromChatId: this.chat.id,
            messageId: this.id,
            ...options,
        });
    }
    copy(chatId, options = {}) {
        return this.client.copyMessage({
            chatId: chatId,
            fromChatId: this.chat.id,
            messageId: this.id,
            ...options,
        });
    }
    pin({ notification = false, businessConnectionId } = {}) {
        return this.client.pinChatMessage({
            chatId: this.chat.id,
            messageId: this.id,
            disableNotification: notification,
            ...(businessConnectionId && { businessConnectionId }),
        });
    }
    unpin(businessConnectionId) {
        return this.client.unpinChatMessage({
            chatId: this.chat.id,
            messageId: this.id,
            ...(businessConnectionId && { businessConnectionId }),
        });
    }
    delete() {
        return this.client.deleteMessage(this.chat.id, this.id);
    }
    editLiveLocation(latitude, longitude, options = {}) {
        return this.client.editMessageLiveLocation({
            chatId: this.chat.id,
            messageId: this.id,
            latitude,
            longitude,
            ...options,
        });
    }
    stopLiveLocation(options = {}) {
        return this.client.stopMessageLiveLocation({
            chatId: this.chat.id,
            messageId: this.id,
            ...options,
        });
    }
}
function reactions(messageReaction) {
    const { added, removed } = messageReaction || {
        added: [],
        removed: [],
    };
    const emoji = isEmoji(added);
    const customEmoji = isCustomEmoji(added);
    const emojiRemoved = isEmoji(removed);
    const customEmojiRemoved = isCustomEmoji(removed);
    const paidAdded = isPaidEmoji(added);
    const paidRemoved = isPaidEmoji(removed);
    const emojiAdded = emoji.filter((emojiItem) => !emojiRemoved.includes(emojiItem));
    const customEmojiAdded = customEmoji.filter((emojiItem) => !customEmojiRemoved.includes(emojiItem));
    const emojiKept = emoji.filter((emojiItem) => emojiRemoved.includes(emojiItem));
    const customEmojiKept = customEmoji.filter((emojiItem) => customEmojiRemoved.includes(emojiItem));
    return {
        emoji: {
            added: emojiAdded,
            kept: emojiKept,
            removed: emojiRemoved,
        },
        customEmoji: {
            added: customEmojiAdded,
            kept: customEmojiKept,
            removed: customEmojiRemoved,
        },
        paid: {
            added: paidAdded,
            removed: paidRemoved,
        },
        isEmoji: () => emojiAdded.length > 0 || emojiKept.length > 0 || emojiRemoved.length > 0,
        isCustomEmoji: () => customEmojiAdded.length > 0 ||
            customEmojiKept.length > 0 ||
            customEmojiRemoved.length > 0,
        isPaidEmoji: () => paidAdded || paidRemoved,
    };
}
function isEmoji(reaction) {
    const reactionTypeEmojis = reaction.filter((react) => react.isEmoji());
    return reactionTypeEmojis.map((react) => react.emoji);
}
function isCustomEmoji(reaction) {
    const reactionTypeCustomEmojis = reaction.filter((react) => react.isCustomEmoji());
    return reactionTypeCustomEmojis.map((react) => react.customEmojiId);
}
function isPaidEmoji(reaction) {
    const reactionTypeCustomEmojis = reaction.filter((react) => react.isPaid());
    return reactionTypeCustomEmojis.length > 0;
}
module.exports = { MessageReactionUpdated };
