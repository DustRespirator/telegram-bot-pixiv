"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MediaData = void 0;
const tslib_1 = require("tslib");
const node_path_1 = tslib_1.__importDefault(require("node:path"));
const node_https_1 = require("node:https");
const node_buffer_1 = require("node:buffer");
const node_crypto_1 = require("node:crypto");
const node_fs_1 = tslib_1.__importStar(require("node:fs"));
const node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
const MultipartStream_1 = require("./MultipartStream");
const ErrorCodes_1 = require("../errors/ErrorCodes");
const TelegramError_1 = require("../errors/TelegramError");
async function fileExists(filePath) {
    try {
        await node_fs_1.default.promises.access(filePath, node_fs_1.default.constants.F_OK);
        return true;
    }
    catch {
        return false;
    }
}
class MediaData {
    constructor() {
        Object.defineProperty(this, "extensions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {
                audio: "mp3",
                photo: "jpg",
                sticker: "webp",
                video: "mp4",
                animation: "mp4",
                video_note: "mp4",
                voice: "ogg",
            }
        });
        Object.defineProperty(this, "formDataJsonFields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: [
                "results",
                "reply_markup",
                "mask_position",
                "shipping_options",
                "errors",
                "commands",
            ]
        });
        Object.defineProperty(this, "sourceParametersMedia", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: [
                "sticker",
                "media",
                "photo",
                "audio",
                "document",
                "video",
                "animation",
                "voice",
                "video_note",
                "certificate",
            ]
        });
    }
    isMediaType(value) {
        return Boolean(typeof value === "object" &&
            value !== null &&
            value.constructor &&
            (value instanceof node_buffer_1.Buffer ||
                value instanceof node_fs_1.ReadStream ||
                value instanceof ArrayBuffer ||
                ArrayBuffer.isView(value) ||
                value instanceof Blob ||
                value instanceof FormData ||
                value instanceof Uint8Array ||
                value instanceof DataView ||
                this.isMediaType(value.source)));
    }
    hasMedia(payload) {
        return Object.keys(payload).some((key) => {
            if (this.sourceParametersMedia.includes(key)) {
                return true;
            }
            if (Array.isArray(payload[key])) {
                return payload[key].some((item) => typeof item === "object" && this.hasMedia(item));
            }
            return false;
        });
    }
    buildJSONConfig(payload, requestOptions = {}) {
        var _a, _b, _c, _d;
        return {
            method: (_a = requestOptions.method) !== null && _a !== void 0 ? _a : "POST",
            compress: (_b = requestOptions.compress) !== null && _b !== void 0 ? _b : true,
            headers: (_c = requestOptions.headers) !== null && _c !== void 0 ? _c : {
                "content-type": "application/json",
                "connection": "keep-alive",
            },
            body: JSON.stringify(payload),
            agent: (_d = requestOptions.agent) !== null && _d !== void 0 ? _d : new node_https_1.Agent({
                keepAlive: true,
                keepAliveMsecs: 10000,
            }),
        };
    }
    async buildFormDataConfig(apiPayload, requestOptions = {}) {
        var _a, _b, _c, _d;
        Object.values(this.formDataJsonFields).map((fieldName) => {
            const fieldValue = apiPayload[fieldName];
            if (fieldValue && typeof fieldValue !== "string") {
                apiPayload[fieldName] = JSON.stringify(fieldValue);
            }
        });
        const boundary = (0, node_crypto_1.randomBytes)(32).toString("hex");
        const formData = new MultipartStream_1.MultipartStream(boundary);
        await Promise.all(Object.keys(apiPayload).map(async (fieldName) => await this.attachFormValue(formData, fieldName, apiPayload[fieldName], requestOptions.agent)));
        return {
            method: (_a = requestOptions.method) !== null && _a !== void 0 ? _a : "POST",
            compress: (_b = requestOptions.compress) !== null && _b !== void 0 ? _b : true,
            headers: (_c = requestOptions.headers) !== null && _c !== void 0 ? _c : {
                "content-type": `multipart/form-data; boundary=${boundary}`,
                "connection": "keep-alive",
            },
            body: formData,
            agent: (_d = requestOptions.agent) !== null && _d !== void 0 ? _d : new node_https_1.Agent({
                keepAlive: true,
                keepAliveMsecs: 10000,
            }),
        };
    }
    async attachFormValue(form, id, value, agent) {
        if (!value)
            return;
        if (typeof value === "string") {
            if (await fileExists(value)) {
                await this.attachFormMedia(form, value, { id });
                return;
            }
            else if (id === "thumbnail" && value.startsWith("http")) {
                const attachmentId = (0, node_crypto_1.randomBytes)(16).toString("hex");
                const response = await (0, node_fetch_1.default)(value, { agent });
                value = node_buffer_1.Buffer.from(await response.arrayBuffer());
                await this.attachFormMedia(form, value, { id: attachmentId });
                form.addPart({
                    headers: { "content-disposition": `form-data; name="${id}"` },
                    body: `attach://${attachmentId}`,
                });
                return;
            }
            else {
                form.addPart({
                    headers: { "content-disposition": `form-data; name="${id}"` },
                    body: String(value),
                });
                return;
            }
        }
        if (typeof value === "object" && value !== null && "source" in value) {
            await this.attachFormMedia(form, value.source.media, {
                id,
                ...("filename" in (value.source || {}) && {
                    filename: value.source.filename,
                }),
            });
            return;
        }
        if (typeof value === "boolean" || typeof value === "number") {
            form.addPart({
                headers: { "content-disposition": `form-data; name="${id}"` },
                body: String(value),
            });
            return;
        }
        if (id === "thumbnail") {
            const attachmentId = (0, node_crypto_1.randomBytes)(16).toString("hex");
            await this.attachFormMedia(form, value, { id: attachmentId });
            form.addPart({
                headers: { "content-disposition": `form-data; name="${id}"` },
                body: `attach://${attachmentId}`,
            });
            return;
        }
        if (id === "cover") {
            const attachmentId = (0, node_crypto_1.randomBytes)(16).toString("hex");
            await this.attachFormMedia(form, value, { id: attachmentId });
            form.addPart({
                headers: { "content-disposition": `form-data; name="${id}"` },
                body: `attach://${attachmentId}`,
            });
            return;
        }
        if (Array.isArray(value)) {
            const attachments = await Promise.all(value.map(async (item) => {
                var _a;
                const media = ((_a = item.media) === null || _a === void 0 ? void 0 : _a.source) ? item.media.source : item;
                if (!this.isMediaType(media.media)) {
                    if (!(await fileExists(media.media))) {
                        return media;
                    }
                }
                const attachmentId = (0, node_crypto_1.randomBytes)(16).toString("hex");
                await this.attachFormMedia(form, media.media, {
                    id: attachmentId,
                    ...(typeof media.media === "object" &&
                        "filename" in (media.media || {}) && {
                        filename: media.media.filename,
                    }),
                });
                if (item.media.source) {
                    return { type: item.type, media: `attach://${attachmentId}` };
                }
                return { ...media, media: `attach://${attachmentId}` };
            }));
            form.addPart({
                headers: { "content-disposition": `form-data; name="${id}"` },
                body: JSON.stringify(attachments),
            });
            return;
        }
        if (value instanceof ArrayBuffer || ArrayBuffer.isView(value)) {
            const buffer = ArrayBuffer.isView(value)
                ? node_buffer_1.Buffer.from(value.buffer, value.byteOffset, value.byteLength)
                : node_buffer_1.Buffer.from(value);
            await this.attachFormMedia(form, buffer, { id });
            return;
        }
        if (value instanceof Blob) {
            const buffer = node_buffer_1.Buffer.from(await value.arrayBuffer());
            await this.attachFormMedia(form, buffer, { id });
            return;
        }
        if (value instanceof FormData) {
            const formThis = form;
            for (const [formKey, formValue] of value.entries()) {
                await this.attachFormValue(formThis, formKey, formValue, agent);
            }
            return;
        }
        if (value instanceof Uint8Array || value instanceof DataView) {
            await this.attachFormMedia(form, node_buffer_1.Buffer.from(value.buffer), { id });
            return;
        }
        await this.attachFormMedia(form, value, { id });
    }
    async attachFormMedia(form, media, options) {
        let filename = null;
        if (options.filename) {
            filename = options.filename;
        }
        else if (options.id) {
            if (typeof media === "string") {
                filename = media;
            }
            else {
                filename = `${options.id}.${this.extensions[options.id] || node_path_1.default.parse(`${media}`).ext || "txt"}`;
            }
        }
        if (!filename) {
            throw new TelegramError_1.TelegramError(ErrorCodes_1.ErrorCodes.InvalidFileName);
        }
        if (typeof media === "string") {
            if (await fileExists(media)) {
                media = node_fs_1.default.createReadStream(media);
            }
        }
        if (MultipartStream_1.MultipartStream.isStream(media) || node_buffer_1.Buffer.isBuffer(media)) {
            await form.addPart({
                headers: {
                    "content-disposition": `form-data; name="${options.id}"; filename="${filename}"`,
                },
                body: media,
            });
        }
    }
}
exports.MediaData = MediaData;
