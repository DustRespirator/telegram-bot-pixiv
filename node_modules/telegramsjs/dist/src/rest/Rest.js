"use strict";
var _Rest_authToken;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Rest = void 0;
const tslib_1 = require("tslib");
const MediaData_1 = require("./MediaData");
const node_events_1 = require("node:events");
const node_timers_1 = require("node:timers");
const collection_1 = require("@telegram.ts/collection");
const node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
const HTTPResponseError_1 = require("../errors/HTTPResponseError");
class Rest extends node_events_1.EventEmitter {
    constructor(authToken, requestOptions) {
        super();
        _Rest_authToken.set(this, void 0);
        Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "media", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new MediaData_1.MediaData()
        });
        Object.defineProperty(this, "rateLimitState", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new collection_1.Collection()
        });
        tslib_1.__classPrivateFieldSet(this, _Rest_authToken, authToken, "f");
        if (requestOptions) {
            this.options = requestOptions;
        }
    }
    on(event, listener) {
        super.on(event, listener);
        return this;
    }
    once(event, listener) {
        super.once(event, listener);
        return this;
    }
    async transferDataToServer(options) {
        if (this.media.hasMedia(options)) {
            return await this.media.buildFormDataConfig(options, this.options);
        }
        else {
            return this.media.buildJSONConfig(options, this.options);
        }
    }
    async request(method, options = {}) {
        var _a, _b;
        const currentTime = Date.now();
        if ((_a = this.options) === null || _a === void 0 ? void 0 : _a.enableRateLimit) {
            const retryAfter = this.rateLimitState.get(method) || 0;
            if (currentTime < retryAfter) {
                const waitTime = retryAfter - currentTime;
                await new Promise((resolve) => (0, node_timers_1.setTimeout)(resolve, waitTime));
            }
        }
        const apiUrl = `https://api.telegram.org/bot${tslib_1.__classPrivateFieldGet(this, _Rest_authToken, "f")}/${method}`;
        const config = await this.transferDataToServer(options);
        this.emit("apiRequest", method, config);
        const request = await (0, node_fetch_1.default)(apiUrl, config);
        const response = await request.json();
        this.emit("apiResponse", method, response);
        if (!response.ok) {
            if ("parameters" in response) {
                if (response.parameters.retry_after) {
                    if ((_b = this.options) === null || _b === void 0 ? void 0 : _b.enableRateLimit) {
                        this.rateLimitState.set(method, currentTime + response.parameters.retry_after * 1000);
                    }
                    this.emit("rateLimit", {
                        method,
                        retryAfter: response.parameters.retry_after,
                        ...(response.parameters.migrate_to_chat_id && {
                            migrateToChatId: String(response.parameters.migrate_to_chat_id),
                        }),
                    });
                }
            }
            throw new HTTPResponseError_1.HTTPResponseError(response, request);
        }
        return response.result;
    }
}
exports.Rest = Rest;
_Rest_authToken = new WeakMap();
