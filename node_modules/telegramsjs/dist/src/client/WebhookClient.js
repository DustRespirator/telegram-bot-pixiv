"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebhookClient = void 0;
const tslib_1 = require("tslib");
const node_https_1 = tslib_1.__importDefault(require("node:https"));
const safe_compare_1 = tslib_1.__importDefault(require("safe-compare"));
const Constants_1 = require("../util/Constants");
const TelegramError_1 = require("../errors/TelegramError");
const ErrorCodes_1 = require("../errors/ErrorCodes");
const node_http_1 = tslib_1.__importDefault(require("node:http"));
class WebhookClient {
    constructor(client) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: client
        });
        Object.defineProperty(this, "offset", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "isClosed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "webhookServer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "webhookFilter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (request, options) => {
                if ((0, safe_compare_1.default)(options.path, request.url)) {
                    if (!options.secretToken) {
                        return true;
                    }
                    else {
                        const token = request.headers["x-telegram-bot-api-secret-token"];
                        if ((0, safe_compare_1.default)(options.secretToken, token)) {
                            return true;
                        }
                    }
                }
                return false;
            }
        });
    }
    async startWebhook(path = "/", secretToken = "", options = {}) {
        try {
            const { tlsOptions, port, host, requestCallback } = options;
            const webhookCallback = await this.createWebhookCallback(requestCallback, {
                path,
                secretToken,
            });
            const serverOptions = tlsOptions != null ? tlsOptions : {};
            this.webhookServer =
                tlsOptions != null
                    ? node_https_1.default.createServer(serverOptions, webhookCallback)
                    : node_http_1.default.createServer(webhookCallback);
            if (!this.webhookServer) {
                throw new TelegramError_1.TelegramError(ErrorCodes_1.ErrorCodes.WebhookServerCreationFailed);
            }
            this.webhookServer.listen(port, host, async () => {
                await this.client.getMe().then((me) => {
                    this.client.user = me;
                    this.client.readyTimestamp = Date.now();
                    this.client.emit(Constants_1.Events.Ready, this.client);
                });
            });
            this.webhookServer.on("error", (err) => {
                if (this.client.eventNames().indexOf(Constants_1.Events.Error) === -1) {
                    this.client.emit(Constants_1.Events.Disconnect);
                    throw err;
                }
                this.client.emit(Constants_1.Events.Error, [this.offset, err]);
            });
        }
        catch (err) {
            this.client.emit(Constants_1.Events.Disconnect);
            if (this.client.eventNames().indexOf(Constants_1.Events.Error) === -1) {
                throw err;
            }
            this.client.emit(Constants_1.Events.Error, [this.offset, err]);
        }
    }
    async createWebhookCallback(requestCallback, { path, secretToken } = {}) {
        const callback = async (request, response) => {
            if (!this.webhookFilter(request, {
                path: path || "/",
                secretToken: secretToken || "",
                token: this.client.authToken,
            })) {
                response.statusCode = 403;
                response.end();
                return;
            }
            let update;
            try {
                if (request.body != null) {
                    let body = request.body;
                    if (body instanceof Buffer)
                        body = String(request.body);
                    if (typeof body === "string")
                        body = JSON.parse(body);
                    update = body;
                }
                else {
                    let body = "";
                    for await (const chunk of request)
                        body += String(chunk);
                    update = JSON.parse(body);
                }
            }
            catch (err) {
                response.writeHead(415).end();
                return;
            }
            if (update) {
                this.offset = update.update_id + 1;
            }
            const res = await this.client.worket.processUpdate(update);
            if (res) {
                this.client.updates.set(this.offset, res);
            }
        };
        return requestCallback
            ? (request, response) => callback(request, response)
            : callback;
    }
    close() {
        if (this.webhookServer && !this.isClosed) {
            this.webhookServer.close(() => {
                this.isClosed = true;
            });
        }
        return this.isClosed;
    }
}
exports.WebhookClient = WebhookClient;
