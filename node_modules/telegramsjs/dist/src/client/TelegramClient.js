"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TelegramClient = void 0;
const tslib_1 = require("tslib");
const node_url_1 = tslib_1.__importDefault(require("node:url"));
const BaseClient_1 = require("./BaseClient");
const PollingClient_1 = require("./PollingClient");
const WebhookClient_1 = require("./WebhookClient");
const WorkerClient_1 = require("./WorkerClient");
const TelegramError_1 = require("../errors/TelegramError");
const ErrorCodes_1 = require("../errors/ErrorCodes");
const Constants_1 = require("../util/Constants");
class TelegramClient extends BaseClient_1.BaseClient {
    constructor(authToken, options = Constants_1.DefaultClientParameters) {
        super(authToken, { ...Constants_1.DefaultClientParameters, ...options });
        Object.defineProperty(this, "authToken", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: authToken
        });
        Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: options
        });
        Object.defineProperty(this, "polling", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "webhook", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "worket", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "readyTimestamp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "user", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.assign(this.options, { ...Constants_1.DefaultClientParameters, ...options });
        if (!authToken) {
            throw new TelegramError_1.TelegramError(ErrorCodes_1.ErrorCodes.MissingToken);
        }
        this.polling = new PollingClient_1.PollingClient(this, options === null || options === void 0 ? void 0 : options.offset);
        this.webhook = new WebhookClient_1.WebhookClient(this);
        this.worket = new WorkerClient_1.WorketClient(this);
    }
    get uptime() {
        return this.readyTimestamp && Date.now() - this.readyTimestamp;
    }
    async fetchApplication() {
        const client = await this.getMe();
        this.user = client;
        return client;
    }
    async login(options = { polling: Constants_1.DefaultPollingParameters }) {
        var _a, _b, _c, _d, _e, _f;
        var _g, _h, _j;
        if ("polling" in options) {
            await this.deleteWebhook((_a = options.polling) === null || _a === void 0 ? void 0 : _a.dropPendingUpdates);
            await this.polling.startPolling({
                ...Constants_1.DefaultPollingParameters,
                ...options.polling,
            });
            return;
        }
        if ("webhook" in options) {
            if (typeof ((_b = options.webhook) === null || _b === void 0 ? void 0 : _b.url) !== "string") {
                throw new TelegramError_1.TelegramError(ErrorCodes_1.ErrorCodes.MissingUrlParameter);
            }
            const parsedUrl = node_url_1.default.parse(options.webhook.url);
            (_c = (_g = options.webhook).path) !== null && _c !== void 0 ? _c : (_g.path = (_d = parsedUrl.path) !== null && _d !== void 0 ? _d : "/");
            if (parsedUrl.port) {
                (_e = (_h = options.webhook).port) !== null && _e !== void 0 ? _e : (_h.port = Number(parsedUrl.port));
            }
            if (parsedUrl.host) {
                (_f = (_j = options.webhook).host) !== null && _f !== void 0 ? _f : (_j.host = parsedUrl.host);
            }
            await this.setWebhook({
                allowedUpdates: Constants_1.DefaultPollingParameters.allowedUpdates,
                ...options.webhook,
            });
            await this.webhook.startWebhook(options.webhook.path, options.webhook.secretToken, options.webhook);
            return;
        }
        throw new TelegramError_1.TelegramError(ErrorCodes_1.ErrorCodes.InvalidOptions);
    }
    destroy() {
        this.polling.close();
        this.webhook.close();
        this.emit(Constants_1.Events.Disconnect, this);
    }
    async [Symbol.asyncDispose]() {
        await this.destroy();
    }
}
exports.TelegramClient = TelegramClient;
