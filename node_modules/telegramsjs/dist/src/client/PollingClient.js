"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PollingClient = void 0;
const Constants_1 = require("../util/Constants");
class PollingClient {
    constructor(client, offset) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: client
        });
        Object.defineProperty(this, "offset", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "isClosed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        this.offset = offset || 0;
    }
    async startPolling(options = {}) {
        try {
            const res = await this.client.getMe();
            this.client.user = res;
            this.client.readyTimestamp = Date.now();
            this.client.emit(Constants_1.Events.Ready, this.client);
            await this.poll(options);
        }
        catch (err) {
            if (this.client.eventNames().indexOf(Constants_1.Events.Error) === -1) {
                this.client.emit(Constants_1.Events.Disconnect);
                throw err;
            }
            this.client.emit(Constants_1.Events.Error, [this.offset, err]);
        }
    }
    async poll(options) {
        var _a, _b;
        try {
            const response = await this.client.getUpdates({
                ...options,
                offset: this.offset,
            });
            if (response.length > 0) {
                const lastItem = response[response.length - 1];
                if (lastItem) {
                    this.offset = lastItem.update_id + 1;
                }
            }
            for (const data of response) {
                const update = await this.client.worket.processUpdate(data);
                if (update) {
                    this.client.updates.set(this.offset, update);
                }
            }
        }
        catch (err) {
            this.client.emit(Constants_1.Events.Disconnect);
            if (this.client.eventNames().indexOf(Constants_1.Events.Error) === -1) {
                throw err;
            }
            this.client.emit(Constants_1.Events.Error, [this.offset, err]);
        }
        finally {
            if (!this.isClosed) {
                setTimeout(async () => {
                    await this.poll(options);
                }, (_b = (_a = this.client.options) === null || _a === void 0 ? void 0 : _a.pollingTimeout) !== null && _b !== void 0 ? _b : 300);
            }
        }
    }
    close() {
        return (this.isClosed = true);
    }
}
exports.PollingClient = PollingClient;
