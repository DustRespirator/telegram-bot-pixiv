"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyboardBuilder = void 0;
class KeyboardBuilder {
    constructor(keyboard = [[]]) {
        Object.defineProperty(this, "keyboard", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: keyboard
        });
        Object.defineProperty(this, "is_persistent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "selective", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "one_time_keyboard", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "resize_keyboard", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "input_field_placeholder", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    add(...buttons) {
        var _a;
        (_a = this.keyboard[this.keyboard.length - 1]) === null || _a === void 0 ? void 0 : _a.push(...buttons);
        return this;
    }
    row(...buttons) {
        this.keyboard.push(buttons);
        return this;
    }
    text(text) {
        return this.add(KeyboardBuilder.text(text));
    }
    static text(text) {
        return { text };
    }
    requestUsers(text, requestId, options = {}) {
        return this.add(KeyboardBuilder.requestUsers(text, requestId, options));
    }
    static requestUsers(text, requestId, options = {}) {
        return { text, request_users: { request_id: requestId, ...options } };
    }
    requestChat(text, requestId, options = {
        chat_is_channel: false,
    }) {
        return this.add(KeyboardBuilder.requestChat(text, requestId, options));
    }
    static requestChat(text, requestId, options = {
        chat_is_channel: false,
    }) {
        return { text, request_chat: { request_id: requestId, ...options } };
    }
    requestContact(text) {
        return this.add(KeyboardBuilder.requestContact(text));
    }
    static requestContact(text) {
        return { text, request_contact: true };
    }
    requestLocation(text) {
        return this.add(KeyboardBuilder.requestLocation(text));
    }
    static requestLocation(text) {
        return { text, request_location: true };
    }
    requestPoll(text, type) {
        return this.add(KeyboardBuilder.requestPoll(text, type));
    }
    static requestPoll(text, type = "regular") {
        return { text, request_poll: { type } };
    }
    webApp(text, url) {
        return this.add(KeyboardBuilder.webApp(text, url));
    }
    static webApp(text, url) {
        return { text, web_app: { url } };
    }
    persistent(isEnabled = true) {
        this.is_persistent = isEnabled;
        return this;
    }
    selected(isEnabled = true) {
        this.selective = isEnabled;
        return this;
    }
    oneTime(isEnabled = true) {
        this.one_time_keyboard = isEnabled;
        return this;
    }
    resized(isEnabled = true) {
        this.resize_keyboard = isEnabled;
        return this;
    }
    placeholder(value) {
        this.input_field_placeholder = value;
        return this;
    }
    clone(keyboard = this.keyboard) {
        const clone = new KeyboardBuilder(keyboard.map((row) => row.slice()));
        if (this.is_persistent !== undefined) {
            clone.is_persistent = this.is_persistent;
        }
        if (this.selective !== undefined) {
            clone.selective = this.selective;
        }
        if (this.one_time_keyboard !== undefined) {
            clone.one_time_keyboard = this.one_time_keyboard;
        }
        if (this.resize_keyboard !== undefined) {
            clone.resize_keyboard = this.resize_keyboard;
        }
        if (this.input_field_placeholder) {
            clone.input_field_placeholder = this.input_field_placeholder;
        }
        return clone;
    }
    build() {
        return this.keyboard;
    }
    combine(keyboard) {
        const json = "toJSON" in keyboard ? keyboard.toJSON() : keyboard;
        const buttons = Array.isArray(json) ? json : json.keyboard;
        for (const row of buttons) {
            if (row.length)
                this.row().add(...row);
        }
        return this;
    }
    static from(source) {
        if (source instanceof KeyboardBuilder)
            return source.clone();
        function toButton(btn) {
            return typeof btn === "string" ? KeyboardBuilder.text(btn) : btn;
        }
        return new KeyboardBuilder(source.map((row) => row.map(toButton)));
    }
    equals(other) {
        if (!other)
            return false;
        if (this.keyboard.length !== other.keyboard.length)
            return false;
        if (this.is_persistent !== other.is_persistent)
            return false;
        if (this.selective !== other.selective)
            return false;
        if (this.one_time_keyboard !== other.one_time_keyboard)
            return false;
        if (this.resize_keyboard !== other.resize_keyboard)
            return false;
        if (this.input_field_placeholder !== other.input_field_placeholder)
            return false;
        for (let i = 0; i < this.keyboard.length; i++) {
            const row = this.keyboard[i];
            const otherRow = other.keyboard[i];
            if (!row || !otherRow || row.length !== otherRow.length)
                return false;
            for (let j = 0; j < row.length; j++) {
                const buttonA = row[j];
                const buttonB = otherRow[j];
                if (buttonA === undefined || buttonB === undefined)
                    return false;
                if (typeof buttonA === "string" && typeof buttonB === "string") {
                    if (buttonA !== buttonB)
                        return false;
                }
                else if (typeof buttonA === "object" && typeof buttonB === "object") {
                    if ("text" in buttonA && "text" in buttonB) {
                        if (buttonA.text !== buttonB.text)
                            return false;
                    }
                    else {
                        return false;
                    }
                }
                else {
                    return false;
                }
            }
        }
        return true;
    }
    toJSON() {
        return {
            keyboard: this.keyboard,
            ...(this.one_time_keyboard !== undefined && {
                one_time_keyboard: this.one_time_keyboard,
            }),
            ...(this.persistent !== undefined && {
                is_persistent: this.is_persistent,
            }),
            ...(this.input_field_placeholder && {
                input_field_placeholder: this.input_field_placeholder,
            }),
            ...(this.selective !== undefined && { selective: this.selective }),
            ...(this.resize_keyboard !== undefined && {
                resize_keyboard: this.resize_keyboard,
            }),
        };
    }
}
exports.KeyboardBuilder = KeyboardBuilder;
