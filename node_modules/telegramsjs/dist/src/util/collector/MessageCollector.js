"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageCollector = void 0;
const Constants_1 = require("../Constants");
const TelegramError_1 = require("../../errors/TelegramError");
const ErrorCodes_1 = require("../../errors/ErrorCodes");
const Collector_1 = require("./Collector");
class MessageCollector extends Collector_1.Collector {
    constructor(client, chat, options = {}) {
        super(options);
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: client
        });
        Object.defineProperty(this, "chat", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: chat
        });
        Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: options
        });
        Object.defineProperty(this, "received", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        if (!chat) {
            throw new TelegramError_1.TelegramError(ErrorCodes_1.ErrorCodes.ChatIdNotAvailable);
        }
        client.incrementMaxListeners();
        client.on(Constants_1.Events.Message, this.handleCollect);
        this.once(Constants_1.CollectorEvents.End, () => {
            client.off(Constants_1.Events.Message, this.handleCollect);
            client.decrementMaxListeners();
        });
    }
    collect(message) {
        var _a;
        if (((_a = message.chat) === null || _a === void 0 ? void 0 : _a.id) !== this.chat.id)
            return null;
        this.received++;
        return message.id;
    }
    dispose(message) {
        var _a;
        return ((_a = message.chat) === null || _a === void 0 ? void 0 : _a.id) === this.chat.id ? message.id : null;
    }
    get endReason() {
        const { max, maxProcessed } = this.options;
        if (max && this.collected.size >= max) {
            return "limit";
        }
        if (maxProcessed && this.received === maxProcessed) {
            return "processedLimit";
        }
        return super.endReason;
    }
}
exports.MessageCollector = MessageCollector;
