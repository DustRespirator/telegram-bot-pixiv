"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReactionCollector = void 0;
const collection_1 = require("@telegram.ts/collection");
const Constants_1 = require("../Constants");
const TelegramError_1 = require("../../errors/TelegramError");
const ErrorCodes_1 = require("../../errors/ErrorCodes");
const Collector_1 = require("./Collector");
class ReactionCollector extends Collector_1.Collector {
    constructor(client, chat, options = {}) {
        super(options);
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: client
        });
        Object.defineProperty(this, "chat", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: chat
        });
        Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: options
        });
        Object.defineProperty(this, "received", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "users", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new collection_1.Collection()
        });
        if (!chat) {
            throw new TelegramError_1.TelegramError(ErrorCodes_1.ErrorCodes.ChatIdNotAvailable);
        }
        client.incrementMaxListeners();
        client.on(Constants_1.Events.MessageReaction, this.handleCollect);
        this.once(Constants_1.ReactionCollectorEvents.End, () => {
            client.off(Constants_1.Events.MessageReaction, this.handleCollect);
            client.decrementMaxListeners();
        });
    }
    on(event, listener) {
        super.on(event, listener);
        return this;
    }
    once(event, listener) {
        super.once(event, listener);
        return this;
    }
    collect(reaction) {
        var _a, _b, _c, _d;
        const { chat, emojiSummary, customEmojiSummary, paidEmoji } = reaction;
        if (paidEmoji !== undefined) {
            return null;
        }
        const addedEmoji = (_b = (_a = emojiSummary === null || emojiSummary === void 0 ? void 0 : emojiSummary.added) !== null && _a !== void 0 ? _a : customEmojiSummary === null || customEmojiSummary === void 0 ? void 0 : customEmojiSummary.added) !== null && _b !== void 0 ? _b : [];
        const removedEmoji = (_d = (_c = emojiSummary === null || emojiSummary === void 0 ? void 0 : emojiSummary.removed) !== null && _c !== void 0 ? _c : customEmojiSummary === null || customEmojiSummary === void 0 ? void 0 : customEmojiSummary.removed) !== null && _d !== void 0 ? _d : [];
        const isReactionInCorrectChat = this.chat.id === chat.id;
        const hasNewOrOldReaction = (addedEmoji === null || addedEmoji === void 0 ? void 0 : addedEmoji.length) > 0 || (removedEmoji === null || removedEmoji === void 0 ? void 0 : removedEmoji.length) > 0;
        if (!isReactionInCorrectChat || !hasNewOrOldReaction) {
            return null;
        }
        this.received++;
        this.handleUsers(reaction);
        return addedEmoji[0] || removedEmoji[0] || null;
    }
    dispose(reaction) {
        var _a, _b, _c, _d;
        const { chat, emojiSummary, customEmojiSummary, paidEmoji } = reaction;
        if (paidEmoji !== undefined) {
            return null;
        }
        const addedEmoji = (_b = (_a = emojiSummary === null || emojiSummary === void 0 ? void 0 : emojiSummary.added) !== null && _a !== void 0 ? _a : customEmojiSummary === null || customEmojiSummary === void 0 ? void 0 : customEmojiSummary.added) !== null && _b !== void 0 ? _b : [];
        const removedEmoji = (_d = (_c = emojiSummary === null || emojiSummary === void 0 ? void 0 : emojiSummary.removed) !== null && _c !== void 0 ? _c : customEmojiSummary === null || customEmojiSummary === void 0 ? void 0 : customEmojiSummary.removed) !== null && _d !== void 0 ? _d : [];
        const isReactionInCorrectChat = this.chat.id === chat.id;
        const hasNewOrOldReaction = addedEmoji.length > 0 || removedEmoji.length > 0;
        if (isReactionInCorrectChat && hasNewOrOldReaction) {
            return addedEmoji[0] || removedEmoji[0] || null;
        }
        else {
            return null;
        }
    }
    handleUsers(reaction) {
        var _a;
        if (!((_a = reaction.user) === null || _a === void 0 ? void 0 : _a.id))
            return;
        if (!this.users.has(reaction.user.id)) {
            if (this.users.size === 0) {
                this.emit(Constants_1.ReactionCollectorEvents.Create, reaction);
            }
            this.users.set(reaction.user.id, [reaction]);
            return;
        }
        const getUser = this.users.get(reaction.user.id) || [];
        this.emit(Constants_1.ReactionCollectorEvents.User, new collection_1.Collection([[reaction.user.id, [...getUser, reaction]]]));
        this.users.set(reaction.user.id, [...getUser, reaction]);
        return;
    }
    get endReason() {
        const { max, maxProcessed } = this.options;
        if (max && this.collected.size >= max) {
            return "limit";
        }
        if (maxProcessed && this.received === maxProcessed) {
            return "processedLimit";
        }
        return super.endReason;
    }
}
exports.ReactionCollector = ReactionCollector;
