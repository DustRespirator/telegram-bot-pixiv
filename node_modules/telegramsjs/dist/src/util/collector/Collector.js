"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Collector = void 0;
const node_events_1 = require("node:events");
const Constants_1 = require("../Constants");
const TelegramError_1 = require("../../errors/TelegramError");
const ErrorCodes_1 = require("../../errors/ErrorCodes");
const collection_1 = require("@telegram.ts/collection");
const node_timers_1 = require("node:timers");
class Collector extends node_events_1.EventEmitter {
    constructor(options) {
        super();
        Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: options
        });
        Object.defineProperty(this, "isEnded", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "filter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "collected", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new collection_1.Collection()
        });
        Object.defineProperty(this, "lastCollectedTimestamp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "_timeout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "_idleTimeout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "_endReason", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        this.handleCollect = this.handleCollect.bind(this);
        this.handleDispose = this.handleDispose.bind(this);
        options.max = options.max || 10;
        options.time = options.time || 60000;
        if (typeof options.filter !== "function" && options.filter !== undefined) {
            throw new TelegramError_1.TelegramError(ErrorCodes_1.ErrorCodes.InvalidFilterFunction);
        }
        this.filter = options.filter || (() => true);
        if (options.time) {
            this._timeout = (0, node_timers_1.setTimeout)(() => this.stop("time"), options.time).unref();
        }
        if (options.idle) {
            this._idleTimeout = (0, node_timers_1.setTimeout)(() => this.stop("idle"), options.idle).unref();
        }
    }
    on(event, listener) {
        super.on(event, listener);
        return this;
    }
    once(event, listener) {
        super.once(event, listener);
        return this;
    }
    get lastCollectedAt() {
        return this.lastCollectedTimestamp && new Date(this.lastCollectedTimestamp);
    }
    async handleCollect(msg) {
        const collectedId = await this.collect(msg);
        if (collectedId) {
            const filterResult = await this.filter(msg, this.collected);
            if (filterResult) {
                this.collected.set(collectedId, msg);
                this.emit(Constants_1.CollectorEvents.Collect, msg, this.collected);
                this.lastCollectedTimestamp = Date.now();
                if (this._idleTimeout) {
                    (0, node_timers_1.clearTimeout)(this._idleTimeout);
                    this._idleTimeout = (0, node_timers_1.setTimeout)(() => this.stop("idle"), this.options.idle).unref();
                }
            }
            else {
                this.emit(Constants_1.CollectorEvents.Ignore, msg);
            }
        }
        this.checkEnd();
    }
    async handleDispose(msg) {
        if (!this.options.dispose)
            return;
        const dispose = this.dispose(msg);
        if (!dispose ||
            !(await this.filter(msg, this.collected)) ||
            !this.collected.has(dispose))
            return;
        this.collected.delete(dispose);
        this.emit(Constants_1.CollectorEvents.Dispose, msg, this.collected);
        this.checkEnd();
    }
    get next() {
        return new Promise((resolve, reject) => {
            if (this.isEnded) {
                reject(this.collected);
                return;
            }
            const cleanup = () => {
                this.off(Constants_1.CollectorEvents.Collect, onCollect);
                this.off(Constants_1.CollectorEvents.End, onEnd);
            };
            const onCollect = (item) => {
                cleanup();
                resolve(item);
            };
            const onEnd = () => {
                cleanup();
                reject(this.collected);
            };
            this.on(Constants_1.CollectorEvents.Collect, onCollect);
            this.on(Constants_1.CollectorEvents.End, onEnd);
        });
    }
    stop(reason = "user") {
        if (this.isEnded)
            return;
        if (this._timeout) {
            (0, node_timers_1.clearTimeout)(this._timeout);
            this._timeout = null;
        }
        if (this._idleTimeout) {
            (0, node_timers_1.clearTimeout)(this._idleTimeout);
            this._idleTimeout = null;
        }
        this._endReason = reason;
        this.isEnded = true;
        this.emit(Constants_1.CollectorEvents.End, this.collected, reason);
    }
    resetTimer({ time, idle } = {}) {
        if (this._timeout) {
            (0, node_timers_1.clearTimeout)(this._timeout);
            this._timeout = (0, node_timers_1.setTimeout)(() => this.stop("time"), time || this.options.time).unref();
        }
        if (this._idleTimeout) {
            (0, node_timers_1.clearTimeout)(this._idleTimeout);
            this._idleTimeout = (0, node_timers_1.setTimeout)(() => this.stop("idle"), idle || this.options.idle).unref();
        }
    }
    checkEnd() {
        const reason = this.endReason;
        if (reason)
            this.stop(reason);
        return Boolean(reason);
    }
    async *[Symbol.asyncIterator]() {
        const queue = [];
        const onCollect = (...item) => queue.push(item);
        this.on(Constants_1.CollectorEvents.Collect, onCollect);
        try {
            while (queue.length || !this.isEnded) {
                if (queue.length) {
                    yield queue.shift();
                }
                else {
                    await new Promise((resolve) => {
                        const tick = () => {
                            this.off(Constants_1.CollectorEvents.Collect, tick);
                            this.off(Constants_1.CollectorEvents.End, tick);
                            return resolve(true);
                        };
                        this.on(Constants_1.CollectorEvents.Collect, tick);
                        this.on(Constants_1.CollectorEvents.End, tick);
                    });
                }
            }
        }
        finally {
            this.off(Constants_1.CollectorEvents.Collect, onCollect);
        }
    }
    get endReason() {
        return this._endReason;
    }
}
exports.Collector = Collector;
